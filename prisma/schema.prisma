// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Neon Auth tables
model User {
  id            String    @id @default(uuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String?   // Hashed password for credentials auth
  role          String    @default("user") // "user" or "admin"
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  accounts      Account[]
  sessions      Session[]
  fileUploads   FileUpload[]
  citationChecks CitationCheck[]
  
  // Document sharing relations
  sharedDocuments    DocumentShare[] @relation("SharedWith")
  sharedByMe         DocumentShare[] @relation("SharedBy")
  routedFromMe       DocumentShare[] @relation("RoutedFrom")
  assignedChecks     CitationCheck[] @relation("AssignedChecks")
  savedPrompts       SavedPrompt[]
  
  // Case relations
  ownedCases         Case[]         @relation("CaseOwner")
  caseMemberships    CaseMember[]   @relation("CaseMembers")
  addedCaseMembers   CaseMember[]   @relation("CaseMemberAddedBy")
  addedInfoDocuments CaseInfoDocument[]
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model FileUpload {
  id          String   @id @default(uuid())
  userId      String
  filename    String
  originalName String
  fileSize    Int
  mimeType    String
  blobUrl     String?  // Vercel Blob Storage URL
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Case assignment fields (optional for backward compatibility)
  caseId              String?  // Optional foreign key to Case
  legalDocumentType   String?  // "motion" | "brief" | "memo" | "pleading" | "complaint" | "answer" | etc.
  filedByOrganization String?  // Organization that filed the document
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  case        Case?    @relation(fields: [caseId], references: [id], onDelete: SetNull)
  citationChecks CitationCheck[]
  shares      DocumentShare[]
  
  @@index([userId])
  @@index([caseId])
  @@index([legalDocumentType])
}

model CitationCheck {
  id            String   @id @default(uuid())
  fileUploadId  String
  userId        String
  version       Int      @default(1)
  status        String   @default("uploaded") // uploaded, json_generated, citations_identified, citations_validated, discrepancies_reviewed, finalized, report_generated
  jsonData      Json?    @db.JsonB // Complete document structure with citations, validation results, and metadata - format TBD by parser
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // NEW: Workflow tracking fields (all optional for backward compatibility)
  workflowType      String?   // "standard" | "test_run" | "heavy_analysis" | "custom"
  workflowId        String?   // UUID to group related checks (e.g., test runs, heavy analysis runs)
  workflowStep      String?   // Current step in workflow
  workflowMetadata  Json?     @db.JsonB // Additional workflow-specific metadata
  
  // NEW: Extracted metadata (for querying without parsing JSON)
  documentMetadata  Json?     @db.JsonB // Extracted from jsonData.document.metadata
  citationCount     Int?      // Total citations count
  identificationMethod String? // "custom" | "eyecite"
  
  // NEW: Workflow state tracking
  completedSteps    String[]  @default([]) // Array of completed step IDs
  currentStep       String?   // Current active step
  
  // NEW: Assignment tracking for soft routing
  assignedToId  String?  // User currently working on this check
  assignedAt    DateTime?
  
  fileUpload    FileUpload @relation(fields: [fileUploadId], references: [id], onDelete: Cascade)
  user          User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  assignedTo    User?      @relation("AssignedChecks", fields: [assignedToId], references: [id], onDelete: SetNull)
  validationJob ValidationJob?
  
  @@unique([fileUploadId, version])
  @@index([userId])
  @@index([fileUploadId])
  @@index([workflowType, workflowId]) // For querying workflow groups
  @@index([workflowType]) // For filtering by workflow type
  @@index([assignedToId]) // For querying assigned checks
}

model ValidationJob {
  id            String   @id @default(uuid())
  checkId      String   @unique
  status        String   @default("pending") // pending, processing, completed, failed
  tier2Total    Int
  tier2Completed Int    @default(0)
  tier3Total    Int     @default(0)
  tier3Completed Int    @default(0)
  error         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  check         CitationCheck @relation(fields: [checkId], references: [id], onDelete: Cascade)
  queueItems    ValidationQueueItem[]
  
  @@index([status])
  @@index([checkId])
}

model ValidationQueueItem {
  id            String   @id @default(uuid())
  jobId         String
  citationId    String   // Citation ID from jsonData
  citationIndex Int      // Index in citations array
  tier          String   @default("tier2") // tier2 or tier3
  status        String   @default("pending") // pending, processing, completed, failed
  retryCount    Int      @default(0)
  error         String?
  result        Json?    // Store validation result
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  processedAt   DateTime?
  
  job           ValidationJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  
  @@unique([jobId, citationId, tier])
  @@index([jobId, status])
  @@index([status])
}

model DocumentShare {
  id            String   @id @default(uuid())
  fileUploadId  String
  sharedWithId  String   // User who receives access
  sharedById    String   // User who shared (owner)
  permission    String   @default("view") // "view" | "edit" | "route"
  routedFromId  String?  // If routed, track original owner
  routedAt      DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  fileUpload    FileUpload @relation(fields: [fileUploadId], references: [id], onDelete: Cascade)
  sharedWith    User       @relation("SharedWith", fields: [sharedWithId], references: [id], onDelete: Cascade)
  sharedBy      User       @relation("SharedBy", fields: [sharedById], references: [id], onDelete: Cascade)
  routedFrom    User?      @relation("RoutedFrom", fields: [routedFromId], references: [id], onDelete: SetNull)
  
  @@unique([fileUploadId, sharedWithId]) // One share record per file-user pair
  @@index([fileUploadId])
  @@index([sharedWithId])
  @@index([sharedById])
  @@index([routedFromId])
}

model SavedPrompt {
  id          String   @id @default(uuid())
  userId      String
  name        String
  prompt      String   @db.Text
  isDefault   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
}

model Case {
  id          String   @id @default(uuid())
  name        String
  description String?
  ownerId     String
  status      String?  @default("active") // "active" | "closed" | "archived"
  metadata    Json?    @db.JsonB // Flexible metadata storage
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  owner       User     @relation("CaseOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  documents   FileUpload[]
  members     CaseMember[]
  infoDocuments CaseInfoDocument[]
  
  @@index([ownerId])
  @@index([status])
}

model CaseMember {
  id          String   @id @default(uuid())
  caseId      String
  userId      String
  role        String   @default("member") // "owner" | "editor" | "viewer" | "member"
  addedAt     DateTime @default(now())
  addedById   String?
  
  case        Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user        User     @relation("CaseMembers", fields: [userId], references: [id], onDelete: Cascade)
  addedBy     User?    @relation("CaseMemberAddedBy", fields: [addedById], references: [id], onDelete: SetNull)
  
  @@unique([caseId, userId])
  @@index([caseId])
  @@index([userId])
}

// Future: CaseInfoDocument model (for informational documents not in system)
model CaseInfoDocument {
  id          String   @id @default(uuid())
  caseId      String
  name        String
  description String?
  source      String?  // "external" | "url" | "reference"
  url         String?
  reference   String?
  documentType String?
  metadata    Json?    @db.JsonB
  addedById   String
  addedAt     DateTime @default(now())
  
  case        Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  addedBy     User     @relation(fields: [addedById], references: [id], onDelete: Cascade)
  
  @@index([caseId])
  @@index([addedById])
}

